Architecture-Driven Modernization (ADM) is an initiative which advocates for the application of Model Driven Architecture (MDA) principles to formalize the software reengineering process. 
%
%
%Architecture-Driven Modernization (ADM) has been proposed by Object Management Group (OMG) in order to carry out refactoring following the principles of Model-Driven Architecture (MDA)~\cite{Kleppe:2003}. It has become a great candidate since it aims to promote \textit{(i)} portability, \textit{(ii)} interoperability, and \textit{(iii)} reusability by means of model. 
According to the OMG the most important artifact provided by ADM is the Knowledge Discovery Metamodel (KDM). KDM is an OMG specification adopted as ISO/IEC $19506$ by the International Standards Organization for representing information related to existing software systems.  KDM is structured in a hierarchy of four layers; \textit{Infrastructure Layer}, \textit{Program Elements Layer}, \textit{ Runtime Resource Layer}, and \textit{Abstractions Layer}. We are specially interested in the \textit{Program Elements Layer} because it defines the Code and Action packages which are widely used by our tool. The Code package defines a set meta-classes that represents the common elements in the source-code supported by different programming languages such as: (\textit{i}) \texttt{ClassUnit} and \texttt{InterfaceUnit} which represent classes and interface, respectively, (\textit{ii}) \texttt{StorableUnit} which illustrates attributes and (\textit{iii}) \texttt{MethodUnit} to represent methods, etc. The Action package represent behavior descriptions and control-and-data-flow relationships between code elements.
 

Refactoring has been known and highly used both industrially and academically. It is a form of transformation that was initially defined by Opdyke~\cite{Opdy92b} as ``a change made to the internal structure of the software while preserving its external behavior at the same level of abstraction''. In the area of object-oriented programming, refactorings are the technique of choice for improving the structure of existing code without changing its external behavior~\cite{refactImpro}. They have proved to be useful to improve the quality attributes of source code, and thus, to increase its maintainability. It is possible to identify several catalogs of refactoring for different languages and the most complete and influential was published by Fowler in~\cite{refactImpro}. 
Nowadays, there are researches been carried out about apply refactoring in model instead of source code\cite{Ulrich:2010:IST:1841736}. %Unfortunately, no catalogue of refactorings for the KDM specification exists. 
Nevertheless, although ADM provides the process for refactoring legacy systems by means of KDM, there is a lack of an Integrated Development Environment (IDE) to lead engineers to apply refactorings as such exist in others object-oriented languages. In the same direction, Model-Driven Modernization is a special kind of model transformation that allows us to improve the structure of the model while preserving its internal quality characteristics. Model-Driven Modernization is a considerably new area of research which still needs to reach the level of maturity attained by source code refactoring~\cite{ModelDrivenRefactoring}. 

In order to enable Model-Driven Modernizations in the context of ADM, refactorings for the KDM metamodel are required. In this context, in a parallel research line of the same group, we developed a catalogue of refactorings for the KDM~\cite{iri_catalogue_of_refactoring_2014}. We argue that devising a refactoring catalogue for KDM makes this catalogue language-independent and standardized. However, the KDM metamodel was not created with the goal of being the basis for diagrams, as is the case of UML metamodel. Thereby, in order to make possible to apply fine-grained refactoring in the KDM metamodel, it is necessary to devise a way to view the KDM instance graphically. Furthermore, although there exist tools, which allow the application of refactorings in class diagrams, none of them uses KDM as their underlying metamodel. As UML is not so complete as KDM in terms of abstraction levels and its main focus is on representing diagrams, it is not the best metamodel for modernizations, since modifications in lower levels cannot be propagated to higher levels
%
%However, while software reengineers would greatly benefit from the possibility to assess different choices during the refactorings, in practice they mostly rely on experience or intuition because of the lack of approaches providing comparison between possible variations of a change. 
%Therefore, software reengineers do not have the possibility to easily apply analyses on different source-code version branches of a system and compare them to pick up the most adequate changes. In this context, the motivations for moving from source-code refactoring  to model-driven refactoring are: 
%(\textit{i}) a model provides an abstract view of the system, hence, visualizations of the structural changes required are easier, 
%(\textit{ii}) problems uncovered at the design-level can be improved directly on the model, and 
%(\textit{iii}) using refactoring in high abstract level can allow the software engineer to explore alternate design paths in much cheaper than source-code refactoring.
%

Hence, the main contribution of this paper is the provision of a plug-in on the top of the Eclipse Platform named  \textbf{K}nowledge \textbf{D}iscovery \textbf{M}odel-\textbf{R}efactoring \textbf{E}nvironment (KDM-RE). This plug-in can be used to lead engineers to apply refactorings in KDM, which are based on seventeen well known refactorings\cite{refactImpro}. The IDE as well as the adapted catalogue are based on our experience as model-driven engineering. Also, by using this plug-in the modernizer engineer can visualize the Code package as a UML class diagram, allowing engineers to detect model smells in that diagram. One hypothetical case study was developed in order to exemplify the use of the plug-in.

%Hence, in this paper it is presented a %To overcome the described problems, we devised a
 %plug-in on the top of the Eclipse Platform named  \textbf{K}nowledge \textbf{D}iscovery \textbf{M}odel-\textbf{R}efactoring \textbf{E}nvironment (KDM-RE). By means of this plug-in the modernizer engineer can apply fine-grained refactoring in KDM instances. Also, by using this plug-in the modernizer engineer can visualize the Code package as a UML class diagram, allowing engineers to detect model smells in that diagram. The KDM-RE supports seventeen refactorings described by Fowler~\cite{refactImpro}. One hypothetical case study was developed in order to exemplify the use of the plug-in.


%___________________________________________________________________________________________________________________
%This \textit{plug-in} provides an environment for model-driven refactoring based on KDM models, i.e., we provide a \textit{plug-in} with the ability to improve existing KDM models, yet keeping them in synch with the underlying source-code as well as a class diagram. 
%In addition, this \textit{plug-in} supplies a multiple versions of a system at level models (KDM), enabling to the engineer  to work interactively on multiple models and to explore alternate refactoring path. %Finally, after the best alternate refactoring path is chosen by the engineer, a forward engineering can be performed and the refactored source-code is generated. 
%Notice that KDM-RE supports 17 refactorings that are heavily inspired by the refactorings described by Fowler~\cite{refactImpro}. 
%___________________________________________________________________________________________________________________

This paper is organized as followed: Section~\ref{sec:KDM-RE} provides the background to fully understand our \textit{plug-in} - Section~\ref{sec:refactoring_kdm_kdm_re} depicts information upon the \textit{plug-in} KDM-RE and an case study - in Section~\ref{sec:related} there are related works and in Section~\ref{sec:conclusion} we conclude the paper with some remarks and future directions.

%These refactorings are split up into three groups. The first group named \textbf{Moving Features Between Objects} which consists of relatively simple refactorings such as moving and creating features. The second group called \textbf{Organizing Data} is a set of refactorings to be applied in order to make working with data easier. The third group is named \textbf{Dealing With Generalization} and it represents refactorings to mostly dealing with moving methods and fields around a hierarchy of inheritance. 






